/*const fs = require('fs').promises;
const { updateUserTime, readJSON } = require('../utils/UserUtil'); // Adjust the path as needed
const { expect } = require('chai');

describe('Testing Time in function', function () {
    // Create a temporary copy of the users.json file for testing
    const testUsersFilePath = 'utils/test-users.json';
  
    before(async function () {
      // Copy the contents of users.json to test-users.json for testing
      const usersData = await fs.readFile('utils/users.json', 'utf8');
      await fs.writeFile(testUsersFilePath, usersData, 'utf8');
    });
  
    after(async function () {
      // Clean up: restore the original users.json file
      const testUsersData = await fs.readFile(testUsersFilePath, 'utf8');
      await fs.writeFile('utils/users.json', testUsersData, 'utf8');
      // Delete the temporary test-users.json file
      await fs.unlink(testUsersFilePath);
    });
  
    it('should successfully update the user time on time in', async function () {
        const testUserId = '312'; // Replace with an actual user ID for your test
    
        // Mock the request and response objects
        const req = {
          params: { id: testUserId },
        };
        const res = {
          status: function (code) {
            this.statusCode = code;
            return this;
          },
          json: function (data) {
            this.responseData = data;
          },
        };
    
        // Read the content of users.json before the time in operation
        const usersBeforeTimeIn = await readJSON('utils/users.json');
    
        // Call the updateUserTime function
        await updateUserTime(req, res);
    
        // Check the response status code and message
        expect(res.statusCode).to.equal(200);
        expect(res.responseData.message).to.equal('User time updated successfully!');
    
        // Read the content of users.json after the time in operation
        const usersAfterTimeIn = await readJSON('utils/users.json');
    
        // Find the user in the updated data
        const userAfterTimeIn = usersAfterTimeIn.find(user => user.id === testUserId);
    
        // Check that the user's time_in property has been updated
        expect(userAfterTimeIn.time_in).to.exist;
      });
      it('should handle duplicate "time in" operation', async function () {
        const testUserId = '313'; // Replace with an actual user ID for your test
    
        // Mock the request and response objects for the first time in operation
        const firstTimeInReq = {
          params: { id: testUserId },
        };
        const firstTimeInRes = {
          status: function (code) {
            this.statusCode = code;
            return this;
          },
          json: function (data) {
            this.responseData = data;
          },
        };
    
        // Mock the request and response objects for the second time in operation
        const secondTimeInReq = {
          params: { id: testUserId },
        };
        const secondTimeInRes = {
          status: function (code) {
            this.statusCode = code;
            return this;
          },
          json: function (data) {
            this.responseData = data;
          },
        };
    
        // Call the updateUserTime function for the first time in operation
        await updateUserTime(firstTimeInReq, firstTimeInRes);
    
        // Check the response status code and message for the first time in operation
        expect(firstTimeInRes.statusCode).to.equal(200);
        expect(firstTimeInRes.responseData.message).to.equal('User time updated successfully!');
    
        // Call the updateUserTime function for the second time in operation
        await updateUserTime(secondTimeInReq, secondTimeInRes);
    
        // Check the response status code and message for the second time in operation
        expect(secondTimeInRes.statusCode).to.equal(400);
        expect(secondTimeInRes.responseData.message).to.equal('User already timed in!');
      });

      it('should record the correct time when user times in', async function () {
        const testUserId = '314'; // Replace with an actual user ID for your test
    
        // Mock the request and response objects
        const req = {
          params: { id: testUserId },
        };
        const res = {
          status: function (code) {
            this.statusCode = code;
            return this;
          },
          json: function (data) {
            this.responseData = data;
          },
        };
    
        // Record the current time before the time in operation
        const currentTimeBeforeTimeIn = new Date().toLocaleTimeString();
    
        // Call the updateUserTime function
        await updateUserTime(req, res);
    
        // Check the response status code and message
        expect(res.statusCode).to.equal(200);
        expect(res.responseData.message).to.equal('User time updated successfully!');
    
        // Read the content of users.json after the time in operation
        const usersAfterTimeIn = await readJSON('utils/users.json');
    
        // Find the user in the updated data
        const userAfterTimeIn = usersAfterTimeIn.find(user => user.id === testUserId);
    
        // Check that the user's time_in property matches the current time before the time in operation
        expect(userAfterTimeIn.time_in).to.equal(currentTimeBeforeTimeIn);
      });

      it('should record time within normal time clock range on "time in"', async function () {
        const testUserId = '2'; // Replace with an actual user ID for your test
    
        // Mock the request and response objects
        const req = {
          params: { id: testUserId },
        };
        const res = {
          status: function (code) {
            this.statusCode = code;
            return this;
          },
          json: function (data) {
            this.responseData = data;
          },
        };
    
        // Call the updateUserTime function
        await updateUserTime(req, res);
    
        // Check the response status code and message
        expect(res.statusCode).to.equal(200);
        expect(res.responseData.message).to.equal('User time updated successfully!');
    
        // Read the content of users.json after the time in operation
        const usersAfterTimeIn = await readJSON('utils/users.json');
    
        // Find the user in the updated data
        const userAfterTimeIn = usersAfterTimeIn.find(user => user.id === testUserId);
    
        // Check that the user's time_in property exists
        expect(userAfterTimeIn.time_in).to.exist;
    
        // Validate that the recorded time is within the normal time clock range (e.g., between 00:00 and 23:59)
        const recordedTime = userAfterTimeIn.time_in.split(':');
        const hours = parseInt(recordedTime[0], 10);
        const minutes = parseInt(recordedTime[1], 10);
    
        expect(hours).to.be.at.least(0).and.at.most(23);
        expect(minutes).to.be.at.least(0).and.at.most(59);
      });

      
      it('should handle updating time for a non-existent user', async function () {
        const invalidUserId = '253235'; // Replace with a non-existent user ID
    
        // Mock the request and response objects
        const req = {
          params: { id: invalidUserId },
        };
        const res = {
          status: function (code) {
            this.statusCode = code;
            return this;
          },
          json: function (data) {
            this.responseData = data;
          },
        };
    
        // Call the updateUserTime function for a non-existent user
        await updateUserTime(req, res);
    
        // Check the response status code and message
        expect(res.statusCode).to.equal(404);
        expect(res.responseData.message).to.equal('User not found!');
      });

    });*/function cov_1vs3c6j1ll(){var path="C:\\Users\\eacsa\\Documents\\DVOPS_Projects\\DVOPS-part1\\tests\\timeIn.test.js";var hash="7a39ee65a26c403ed3f93a0680e6623000de7c33";var global=new Function("return this")();var gcv="__coverage__";var coverageData={path:"C:\\Users\\eacsa\\Documents\\DVOPS_Projects\\DVOPS-part1\\tests\\timeIn.test.js",statementMap:{},fnMap:{},branchMap:{},s:{},f:{},b:{},_coverageSchema:"1a1c01bbd47fc00a2c39e90264f33305004495a9",hash:"7a39ee65a26c403ed3f93a0680e6623000de7c33"};var coverage=global[gcv]||(global[gcv]={});if(!coverage[path]||coverage[path].hash!==hash){coverage[path]=coverageData;}var actualCoverage=coverage[path];{// @ts-ignore
cov_1vs3c6j1ll=function(){return actualCoverage;};}return actualCoverage;}cov_1vs3c6j1ll();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMXZzM2M2ajFsbCIsInBhdGgiLCJoYXNoIiwiZ2xvYmFsIiwiRnVuY3Rpb24iLCJnY3YiLCJjb3ZlcmFnZURhdGEiLCJzdGF0ZW1lbnRNYXAiLCJmbk1hcCIsImJyYW5jaE1hcCIsInMiLCJmIiwiYiIsIl9jb3ZlcmFnZVNjaGVtYSIsImNvdmVyYWdlIiwiYWN0dWFsQ292ZXJhZ2UiXSwic291cmNlcyI6WyJ0aW1lSW4udGVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKS5wcm9taXNlcztcclxuY29uc3QgeyB1cGRhdGVVc2VyVGltZSwgcmVhZEpTT04gfSA9IHJlcXVpcmUoJy4uL3V0aWxzL1VzZXJVdGlsJyk7IC8vIEFkanVzdCB0aGUgcGF0aCBhcyBuZWVkZWRcclxuY29uc3QgeyBleHBlY3QgfSA9IHJlcXVpcmUoJ2NoYWknKTtcclxuXHJcbmRlc2NyaWJlKCdUZXN0aW5nIFRpbWUgaW4gZnVuY3Rpb24nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgY29weSBvZiB0aGUgdXNlcnMuanNvbiBmaWxlIGZvciB0ZXN0aW5nXHJcbiAgICBjb25zdCB0ZXN0VXNlcnNGaWxlUGF0aCA9ICd1dGlscy90ZXN0LXVzZXJzLmpzb24nO1xyXG4gIFxyXG4gICAgYmVmb3JlKGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gQ29weSB0aGUgY29udGVudHMgb2YgdXNlcnMuanNvbiB0byB0ZXN0LXVzZXJzLmpzb24gZm9yIHRlc3RpbmdcclxuICAgICAgY29uc3QgdXNlcnNEYXRhID0gYXdhaXQgZnMucmVhZEZpbGUoJ3V0aWxzL3VzZXJzLmpzb24nLCAndXRmOCcpO1xyXG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUodGVzdFVzZXJzRmlsZVBhdGgsIHVzZXJzRGF0YSwgJ3V0ZjgnKTtcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgYWZ0ZXIoYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyBDbGVhbiB1cDogcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXNlcnMuanNvbiBmaWxlXHJcbiAgICAgIGNvbnN0IHRlc3RVc2Vyc0RhdGEgPSBhd2FpdCBmcy5yZWFkRmlsZSh0ZXN0VXNlcnNGaWxlUGF0aCwgJ3V0ZjgnKTtcclxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKCd1dGlscy91c2Vycy5qc29uJywgdGVzdFVzZXJzRGF0YSwgJ3V0ZjgnKTtcclxuICAgICAgLy8gRGVsZXRlIHRoZSB0ZW1wb3JhcnkgdGVzdC11c2Vycy5qc29uIGZpbGVcclxuICAgICAgYXdhaXQgZnMudW5saW5rKHRlc3RVc2Vyc0ZpbGVQYXRoKTtcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgdXBkYXRlIHRoZSB1c2VyIHRpbWUgb24gdGltZSBpbicsIGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCB0ZXN0VXNlcklkID0gJzMxMic7IC8vIFJlcGxhY2Ugd2l0aCBhbiBhY3R1YWwgdXNlciBJRCBmb3IgeW91ciB0ZXN0XHJcbiAgICBcclxuICAgICAgICAvLyBNb2NrIHRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBvYmplY3RzXHJcbiAgICAgICAgY29uc3QgcmVxID0ge1xyXG4gICAgICAgICAgcGFyYW1zOiB7IGlkOiB0ZXN0VXNlcklkIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICBzdGF0dXM6IGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGpzb246IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VEYXRhID0gZGF0YTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgIC8vIFJlYWQgdGhlIGNvbnRlbnQgb2YgdXNlcnMuanNvbiBiZWZvcmUgdGhlIHRpbWUgaW4gb3BlcmF0aW9uXHJcbiAgICAgICAgY29uc3QgdXNlcnNCZWZvcmVUaW1lSW4gPSBhd2FpdCByZWFkSlNPTigndXRpbHMvdXNlcnMuanNvbicpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgdXBkYXRlVXNlclRpbWUgZnVuY3Rpb25cclxuICAgICAgICBhd2FpdCB1cGRhdGVVc2VyVGltZShyZXEsIHJlcyk7XHJcbiAgICBcclxuICAgICAgICAvLyBDaGVjayB0aGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgYW5kIG1lc3NhZ2VcclxuICAgICAgICBleHBlY3QocmVzLnN0YXR1c0NvZGUpLnRvLmVxdWFsKDIwMCk7XHJcbiAgICAgICAgZXhwZWN0KHJlcy5yZXNwb25zZURhdGEubWVzc2FnZSkudG8uZXF1YWwoJ1VzZXIgdGltZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseSEnKTtcclxuICAgIFxyXG4gICAgICAgIC8vIFJlYWQgdGhlIGNvbnRlbnQgb2YgdXNlcnMuanNvbiBhZnRlciB0aGUgdGltZSBpbiBvcGVyYXRpb25cclxuICAgICAgICBjb25zdCB1c2Vyc0FmdGVyVGltZUluID0gYXdhaXQgcmVhZEpTT04oJ3V0aWxzL3VzZXJzLmpzb24nKTtcclxuICAgIFxyXG4gICAgICAgIC8vIEZpbmQgdGhlIHVzZXIgaW4gdGhlIHVwZGF0ZWQgZGF0YVxyXG4gICAgICAgIGNvbnN0IHVzZXJBZnRlclRpbWVJbiA9IHVzZXJzQWZ0ZXJUaW1lSW4uZmluZCh1c2VyID0+IHVzZXIuaWQgPT09IHRlc3RVc2VySWQpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdXNlcidzIHRpbWVfaW4gcHJvcGVydHkgaGFzIGJlZW4gdXBkYXRlZFxyXG4gICAgICAgIGV4cGVjdCh1c2VyQWZ0ZXJUaW1lSW4udGltZV9pbikudG8uZXhpc3Q7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBkdXBsaWNhdGUgXCJ0aW1lIGluXCIgb3BlcmF0aW9uJywgYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IHRlc3RVc2VySWQgPSAnMzEzJzsgLy8gUmVwbGFjZSB3aXRoIGFuIGFjdHVhbCB1c2VyIElEIGZvciB5b3VyIHRlc3RcclxuICAgIFxyXG4gICAgICAgIC8vIE1vY2sgdGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIG9iamVjdHMgZm9yIHRoZSBmaXJzdCB0aW1lIGluIG9wZXJhdGlvblxyXG4gICAgICAgIGNvbnN0IGZpcnN0VGltZUluUmVxID0ge1xyXG4gICAgICAgICAgcGFyYW1zOiB7IGlkOiB0ZXN0VXNlcklkIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmaXJzdFRpbWVJblJlcyA9IHtcclxuICAgICAgICAgIHN0YXR1czogZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gY29kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAganNvbjogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZURhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgLy8gTW9jayB0aGUgcmVxdWVzdCBhbmQgcmVzcG9uc2Ugb2JqZWN0cyBmb3IgdGhlIHNlY29uZCB0aW1lIGluIG9wZXJhdGlvblxyXG4gICAgICAgIGNvbnN0IHNlY29uZFRpbWVJblJlcSA9IHtcclxuICAgICAgICAgIHBhcmFtczogeyBpZDogdGVzdFVzZXJJZCB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kVGltZUluUmVzID0ge1xyXG4gICAgICAgICAgc3RhdHVzOiBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBqc29uOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgICAgICAvLyBDYWxsIHRoZSB1cGRhdGVVc2VyVGltZSBmdW5jdGlvbiBmb3IgdGhlIGZpcnN0IHRpbWUgaW4gb3BlcmF0aW9uXHJcbiAgICAgICAgYXdhaXQgdXBkYXRlVXNlclRpbWUoZmlyc3RUaW1lSW5SZXEsIGZpcnN0VGltZUluUmVzKTtcclxuICAgIFxyXG4gICAgICAgIC8vIENoZWNrIHRoZSByZXNwb25zZSBzdGF0dXMgY29kZSBhbmQgbWVzc2FnZSBmb3IgdGhlIGZpcnN0IHRpbWUgaW4gb3BlcmF0aW9uXHJcbiAgICAgICAgZXhwZWN0KGZpcnN0VGltZUluUmVzLnN0YXR1c0NvZGUpLnRvLmVxdWFsKDIwMCk7XHJcbiAgICAgICAgZXhwZWN0KGZpcnN0VGltZUluUmVzLnJlc3BvbnNlRGF0YS5tZXNzYWdlKS50by5lcXVhbCgnVXNlciB0aW1lIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IScpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgdXBkYXRlVXNlclRpbWUgZnVuY3Rpb24gZm9yIHRoZSBzZWNvbmQgdGltZSBpbiBvcGVyYXRpb25cclxuICAgICAgICBhd2FpdCB1cGRhdGVVc2VyVGltZShzZWNvbmRUaW1lSW5SZXEsIHNlY29uZFRpbWVJblJlcyk7XHJcbiAgICBcclxuICAgICAgICAvLyBDaGVjayB0aGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgYW5kIG1lc3NhZ2UgZm9yIHRoZSBzZWNvbmQgdGltZSBpbiBvcGVyYXRpb25cclxuICAgICAgICBleHBlY3Qoc2Vjb25kVGltZUluUmVzLnN0YXR1c0NvZGUpLnRvLmVxdWFsKDQwMCk7XHJcbiAgICAgICAgZXhwZWN0KHNlY29uZFRpbWVJblJlcy5yZXNwb25zZURhdGEubWVzc2FnZSkudG8uZXF1YWwoJ1VzZXIgYWxyZWFkeSB0aW1lZCBpbiEnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIHJlY29yZCB0aGUgY29ycmVjdCB0aW1lIHdoZW4gdXNlciB0aW1lcyBpbicsIGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCB0ZXN0VXNlcklkID0gJzMxNCc7IC8vIFJlcGxhY2Ugd2l0aCBhbiBhY3R1YWwgdXNlciBJRCBmb3IgeW91ciB0ZXN0XHJcbiAgICBcclxuICAgICAgICAvLyBNb2NrIHRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBvYmplY3RzXHJcbiAgICAgICAgY29uc3QgcmVxID0ge1xyXG4gICAgICAgICAgcGFyYW1zOiB7IGlkOiB0ZXN0VXNlcklkIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICBzdGF0dXM6IGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGpzb246IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VEYXRhID0gZGF0YTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY3VycmVudCB0aW1lIGJlZm9yZSB0aGUgdGltZSBpbiBvcGVyYXRpb25cclxuICAgICAgICBjb25zdCBjdXJyZW50VGltZUJlZm9yZVRpbWVJbiA9IG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XHJcbiAgICBcclxuICAgICAgICAvLyBDYWxsIHRoZSB1cGRhdGVVc2VyVGltZSBmdW5jdGlvblxyXG4gICAgICAgIGF3YWl0IHVwZGF0ZVVzZXJUaW1lKHJlcSwgcmVzKTtcclxuICAgIFxyXG4gICAgICAgIC8vIENoZWNrIHRoZSByZXNwb25zZSBzdGF0dXMgY29kZSBhbmQgbWVzc2FnZVxyXG4gICAgICAgIGV4cGVjdChyZXMuc3RhdHVzQ29kZSkudG8uZXF1YWwoMjAwKTtcclxuICAgICAgICBleHBlY3QocmVzLnJlc3BvbnNlRGF0YS5tZXNzYWdlKS50by5lcXVhbCgnVXNlciB0aW1lIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IScpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gUmVhZCB0aGUgY29udGVudCBvZiB1c2Vycy5qc29uIGFmdGVyIHRoZSB0aW1lIGluIG9wZXJhdGlvblxyXG4gICAgICAgIGNvbnN0IHVzZXJzQWZ0ZXJUaW1lSW4gPSBhd2FpdCByZWFkSlNPTigndXRpbHMvdXNlcnMuanNvbicpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gRmluZCB0aGUgdXNlciBpbiB0aGUgdXBkYXRlZCBkYXRhXHJcbiAgICAgICAgY29uc3QgdXNlckFmdGVyVGltZUluID0gdXNlcnNBZnRlclRpbWVJbi5maW5kKHVzZXIgPT4gdXNlci5pZCA9PT0gdGVzdFVzZXJJZCk7XHJcbiAgICBcclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB1c2VyJ3MgdGltZV9pbiBwcm9wZXJ0eSBtYXRjaGVzIHRoZSBjdXJyZW50IHRpbWUgYmVmb3JlIHRoZSB0aW1lIGluIG9wZXJhdGlvblxyXG4gICAgICAgIGV4cGVjdCh1c2VyQWZ0ZXJUaW1lSW4udGltZV9pbikudG8uZXF1YWwoY3VycmVudFRpbWVCZWZvcmVUaW1lSW4pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmVjb3JkIHRpbWUgd2l0aGluIG5vcm1hbCB0aW1lIGNsb2NrIHJhbmdlIG9uIFwidGltZSBpblwiJywgYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IHRlc3RVc2VySWQgPSAnMic7IC8vIFJlcGxhY2Ugd2l0aCBhbiBhY3R1YWwgdXNlciBJRCBmb3IgeW91ciB0ZXN0XHJcbiAgICBcclxuICAgICAgICAvLyBNb2NrIHRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBvYmplY3RzXHJcbiAgICAgICAgY29uc3QgcmVxID0ge1xyXG4gICAgICAgICAgcGFyYW1zOiB7IGlkOiB0ZXN0VXNlcklkIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICBzdGF0dXM6IGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IGNvZGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGpzb246IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VEYXRhID0gZGF0YTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgIC8vIENhbGwgdGhlIHVwZGF0ZVVzZXJUaW1lIGZ1bmN0aW9uXHJcbiAgICAgICAgYXdhaXQgdXBkYXRlVXNlclRpbWUocmVxLCByZXMpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGFuZCBtZXNzYWdlXHJcbiAgICAgICAgZXhwZWN0KHJlcy5zdGF0dXNDb2RlKS50by5lcXVhbCgyMDApO1xyXG4gICAgICAgIGV4cGVjdChyZXMucmVzcG9uc2VEYXRhLm1lc3NhZ2UpLnRvLmVxdWFsKCdVc2VyIHRpbWUgdXBkYXRlZCBzdWNjZXNzZnVsbHkhJyk7XHJcbiAgICBcclxuICAgICAgICAvLyBSZWFkIHRoZSBjb250ZW50IG9mIHVzZXJzLmpzb24gYWZ0ZXIgdGhlIHRpbWUgaW4gb3BlcmF0aW9uXHJcbiAgICAgICAgY29uc3QgdXNlcnNBZnRlclRpbWVJbiA9IGF3YWl0IHJlYWRKU09OKCd1dGlscy91c2Vycy5qc29uJyk7XHJcbiAgICBcclxuICAgICAgICAvLyBGaW5kIHRoZSB1c2VyIGluIHRoZSB1cGRhdGVkIGRhdGFcclxuICAgICAgICBjb25zdCB1c2VyQWZ0ZXJUaW1lSW4gPSB1c2Vyc0FmdGVyVGltZUluLmZpbmQodXNlciA9PiB1c2VyLmlkID09PSB0ZXN0VXNlcklkKTtcclxuICAgIFxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHVzZXIncyB0aW1lX2luIHByb3BlcnR5IGV4aXN0c1xyXG4gICAgICAgIGV4cGVjdCh1c2VyQWZ0ZXJUaW1lSW4udGltZV9pbikudG8uZXhpc3Q7XHJcbiAgICBcclxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSByZWNvcmRlZCB0aW1lIGlzIHdpdGhpbiB0aGUgbm9ybWFsIHRpbWUgY2xvY2sgcmFuZ2UgKGUuZy4sIGJldHdlZW4gMDA6MDAgYW5kIDIzOjU5KVxyXG4gICAgICAgIGNvbnN0IHJlY29yZGVkVGltZSA9IHVzZXJBZnRlclRpbWVJbi50aW1lX2luLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgY29uc3QgaG91cnMgPSBwYXJzZUludChyZWNvcmRlZFRpbWVbMF0sIDEwKTtcclxuICAgICAgICBjb25zdCBtaW51dGVzID0gcGFyc2VJbnQocmVjb3JkZWRUaW1lWzFdLCAxMCk7XHJcbiAgICBcclxuICAgICAgICBleHBlY3QoaG91cnMpLnRvLmJlLmF0LmxlYXN0KDApLmFuZC5hdC5tb3N0KDIzKTtcclxuICAgICAgICBleHBlY3QobWludXRlcykudG8uYmUuYXQubGVhc3QoMCkuYW5kLmF0Lm1vc3QoNTkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIFxyXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSB1cGRhdGluZyB0aW1lIGZvciBhIG5vbi1leGlzdGVudCB1c2VyJywgYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGludmFsaWRVc2VySWQgPSAnMjUzMjM1JzsgLy8gUmVwbGFjZSB3aXRoIGEgbm9uLWV4aXN0ZW50IHVzZXIgSURcclxuICAgIFxyXG4gICAgICAgIC8vIE1vY2sgdGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIG9iamVjdHNcclxuICAgICAgICBjb25zdCByZXEgPSB7XHJcbiAgICAgICAgICBwYXJhbXM6IHsgaWQ6IGludmFsaWRVc2VySWQgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgIHN0YXR1czogZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gY29kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAganNvbjogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZURhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgdXBkYXRlVXNlclRpbWUgZnVuY3Rpb24gZm9yIGEgbm9uLWV4aXN0ZW50IHVzZXJcclxuICAgICAgICBhd2FpdCB1cGRhdGVVc2VyVGltZShyZXEsIHJlcyk7XHJcbiAgICBcclxuICAgICAgICAvLyBDaGVjayB0aGUgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgYW5kIG1lc3NhZ2VcclxuICAgICAgICBleHBlY3QocmVzLnN0YXR1c0NvZGUpLnRvLmVxdWFsKDQwNCk7XHJcbiAgICAgICAgZXhwZWN0KHJlcy5yZXNwb25zZURhdGEubWVzc2FnZSkudG8uZXF1YWwoJ1VzZXIgbm90IGZvdW5kIScpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICB9KTsqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBak5BLFNBQUFBLGVBQUEsTUFBQUMsSUFBQSx1RkFBQUMsSUFBQSxnREFBQUMsTUFBQSxLQUFBQyxRQUFBLHNCQUFBQyxHQUFBLG9CQUFBQyxZQUFBLEVBQUFMLElBQUEsbUZBQUFNLFlBQUEsSUFBQUMsS0FBQSxJQUFBQyxTQUFBLElBQUFDLENBQUEsSUFBQUMsQ0FBQSxJQUFBQyxDQUFBLElBQUFDLGVBQUEsNENBQUFYLElBQUEsaURBQUFZLFFBQUEsQ0FBQVgsTUFBQSxDQUFBRSxHQUFBLElBQUFGLE1BQUEsQ0FBQUUsR0FBQSxVQUFBUyxRQUFBLENBQUFiLElBQUEsR0FBQWEsUUFBQSxDQUFBYixJQUFBLEVBQUFDLElBQUEsR0FBQUEsSUFBQSxFQUFBWSxRQUFBLENBQUFiLElBQUEsRUFBQUssWUFBQSxNQUFBUyxjQUFBLENBQUFELFFBQUEsQ0FBQWIsSUFBQSxHQWVZO0FBQUFELGNBQUEsU0FBQUEsQ0FBQSxTQUFBZSxjQUFBLFdBQUFBLGNBQUEsRUFBQWYsY0FBQSJ9